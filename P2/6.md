### 引言--bool数据类型
bool数据类型只有两个值: `True`和`False`

它们分别表示真和假

要把一个值转换为bool类型, 可以使用bool函数

### 示例6.1--难度的输入和自定义难度
有的时候, 我们有这样一个需求: 让用户填一个表格, 但有些项目只有特定选项的时候才会出现

这里就是`if`语句派上用场的时候了

我们要收集两个数据: 难度和自定义值

具体的处理逻辑是: 输入难度, 如果为自定义, 输入自定义值, 否则使用难度对应的值

```python
s = int(input("请输入难度(1(简单)/2(普通)/3(困难)/0(自定义)): "))
value = -1
if s == 1:
    value = 10
if s == 2:
    value = 20
if s == 3:
    value = 40
if s == 0:
    value = int(input("请输入值: "))
if value == -1:
    print("无效的难度")
    exit(1)
print("值 "+str(value))
```

```python
请输入难度(1(简单)/2(普通)/3(困难)/0(自定义)): 1
值 10
---
请输入难度(1(简单)/2(普通)/3(困难)/0(自定义)): 2
值 20
---
请输入难度(1(简单)/2(普通)/3(困难)/0(自定义)): 3
值 40
---
请输入难度(1(简单)/2(普通)/3(困难)/0(自定义)): 0
请输入值: 30
值 30
---
请输入难度(1(简单)/2(普通)/3(困难)/0(自定义)): 4
无效的难度
```

它正常工作了

我们来分析这段代码中的if部分

它可以被提取为这样:

```python
if <bool类型表达式>:
    代码块
```

和def很像, 只是参数部分变成了bool类型表达式

如果if后的表达式是正确的（为真），那么程序将会执行代码块中的内容，否则则跳过

再来看`==`运算符, 它判断两个值是否相等

除此之外还有:

`!=` 不等于`<`小于`>`大于`<=`小于等于`>=`大于等于`is`两个对象是否为同一个

这些运算符的优先级都比算数运算符的优先级要低

它们被称为比较运算符

还有`and``or``not`

not运算符的优先级比比较运算符的优先级高

and比比较运算符低, 最后是or

```python
a = True
b = False

# 比较运算符
print(2 < 3)   # True
print(2 == 3)  # False
print(2 != 3)  # True

# 逻辑运算符
print(a and b)  # False
print(a or b)   # True
print(not a)    # False
```

### 示例6.2--这是一个正确的密码吗
接下来, 我们的需求是输入一个密码, 检测是否和预设匹配, 然后输出对应的消息

需要在密码正确和错误的时候分别提示, 所以我们要用`else`分句来进行处理

```python
password = input("输入密码")
if password == "123456":
    print("成功")
else:
    print("失败")
```

```python
输入密码123456
成功
---
输入密码000000
失败
```

这里出现了else分句, 它会在if不通过的时候执行, 而且只能写在最后

```python
if xxx:
    # ...
else:
    # ...
```

### 示例6.3--多种胜利条件对应多种结局
我们要对游戏的结局进行处理, 我们能拿到目前的两种进度A和B

现在, 这个游戏有4种结局: 走火入魔(B > 85) 大成功(A > 70) 平淡(A > 20 or B > 20) 一事无成(其他情况)

这些结局按顺序判断, 即触发走火入魔后即使A>70也不会触发后面的, 所以我们还要用到`elif`分句

```python
progress_a = int(input("A进度"))
progress_b = int(input("B进度"))
if progress_b > 80:
    print("走火入魔结局")
elif progress_a > 75:
    print("大成功结局")
elif progress_a > 20 or progress_b > 20:
    print("平淡结局")
else:
    print("一事无成结局")
```

```python
A进度85
B进度90
走火入魔结局
---
A进度30
B进度90
走火入魔结局
---
A进度90
B进度80
大成功结局
---
A进度40
B进度35
平淡结局
---
A进度10
B进度10
一事无成结局
```

elif语句会在上一条语句检查失败的时候进行检查, 如果成功则执行, 否则下一条语句

```python
if ...:
    # ...
elif ...:
    # ...
elif ...:
    # ...
# ...
```

### 示例6.4--如果我们提前返回一个函数
大家在学习函数后, 有没有发现一个函数里可以写不止一条的return语句

我们可以利用它和if来做到在条件不匹配时提前返回一个函数

```python
def a(b):
    if b <= 0:
        return -1
    if b == 5:
        return 20
    return b * 10

print(a(-1))
print(a(2))
print(a(5))
print(a(10))
```

```python
-1
20
20
100
```

这样做的好处是不用写else来增加缩进

如果用else会写成这样:

```python
def a(b):
    if b > 0:
        if b != 5:
            return b * 10
        else:
            return 20
    else:
        return -1
```

~~(这一点也不美观)~~

使用提前return可以使代码更整洁~~(当然如果你不给别人看不考虑后续维护的话可以不用管)~~

### 示例6.5--计算从1加到100
如果我们想用python计算从1到100, 就不可避免的谈到循环了

这里我们介绍`for`循环和`range`函数

首先是`range`函数:

它有三种形式(有一种不常用就没讲):

`range(最大) # 从0到(最大-1)`

`range(最小, 最大) # 从最小到(最大-1)`

接下来看代码:

```python
count = 0
for i in range(1, 101):
    count += i
print(count)
```

```python
5050
```

for的语法是: `for var_name in iterable:`

`iterable`是可迭代对象, 具体就是列表, 元组, range产生的东西之类的

当然有人会说我为啥不用`(最小+最大)*项数/~~2~~`~~(这绝对是来捣乱的)~~

是因为有些东西必须用循环, 比如说猜数字之类的依赖于上一次的结果的

### 示例6.6--无止境的复读机
有的时候, 我们希望能无限循环下去, 这时候就要用while循环了

while循环的语法是: `while <bool类型表达式>:`

具体就是如果bool类型表达式为True就会一直循环直到变成False

当然这里因为不会跳出去就直接用True了

```python
while True:
    s = input()
    print(s)
```

```python
123
123
lll
lll
infinite
infinite
```

可以看到它会把输入给重新输出出来

### 示例6.7--让我们主动跳出循环
接下来, 针对上一个示例的复读机, 我们希望输入exit后它能退出

这里我们就要使用`break`语句了, 它会终止当前的循环并且继续外面代码的执行

我们把代码改成这样:

```python
while True:
    s = input()
    if s == "exit":
        break
    print(s)
print("退出了")
```

```python
123
123
183
183
lll
lll
exit
退出了
```

现在, 当它接收到exit后会跳出循环.

### 示例6.8--有没有办法跳过'4'呢?
我们要列出1-100中不含有4的数字:

```python
for i in range(1, 101):
    if str(i).find('4') != -1:
        continue
    print(i, end=" ")
```

```python
1 2 3 5 6 7 8 9 10 11 12 13 15 16 17 18 19 20 21 22 23 25 26 27 28 29 30 31 32 33 35 36 37 38 39 50 51 52 53 55 56 57 58 59 60 61 62 63 65 66 67 68 69 70 71 72 73 75 76 77 78 79 80 81 82 83 85 86 87 88 89 90 91 92 93 95 96 97 98 99 100
```

我们使用了continue语句, 它会终止下面的代码的执行并且进入下一次循环

print函数可以接受一个键值对参数: end, 表示打印之后后面跟的字符串

str的find方法可以寻找指定的子字符串, 找不到会返回-1

### 扩展6.a--使用递归代替循环
我们可以使用递归来代替循环, 这里是一个从1加到100的例子:

```python
def count(num):
    if num == 0:
        return 0
    return count(num - 1) + num

print(count(100))
```

```python
5050
```

递归实际上就是将一个问题分解为同类更小的问题

